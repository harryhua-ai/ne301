(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? (module.exports = factory())
        : typeof define === 'function' && define.amd
        ? define(factory)
        : (global.JMuxer = factory())
}(this, () => {
    const classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
        }
    }

    const createClass = (function () {
        function defineProperties(target, props) {
            for (let i = 0; i < props.length; i++) {
                const descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps)
            if (staticProps) defineProperties(Constructor, staticProps)
            return Constructor
        }
    }())

    const defineProperty = function (obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true,
            })
        } else {
            obj[key] = value
        }

        return obj
    }

    const inherits = function (subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError(`Super expression must either be null or a function, not ${typeof superClass}`)
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true,
            },
        })
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass)
    }

    const possibleConstructorReturn = function (self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }

        return call && (typeof call === 'object' || typeof call === 'function') ? call : self
    }

    const NALU = (function () {
        createClass(NALU, null, [
            {
                key: 'type',
                value: function type(nalu) {
                    if (nalu.ntype in NALU.TYPES) {
                        return NALU.TYPES[nalu.ntype]
                    } 
                        return 'UNKNOWN'
                },
            },
            {
                key: 'NDR',
                get: function get$$1() {
                    return 1
                },
            },
            {
                key: 'IDR',
                get: function get$$1() {
                    return 5
                },
            },
            {
                key: 'SEI',
                get: function get$$1() {
                    return 6
                },
            },
            {
                key: 'SPS',
                get: function get$$1() {
                    return 7
                },
            },
            {
                key: 'PPS',
                get: function get$$1() {
                    return 8
                },
            },
            {
                key: 'AUD',
                get: function get$$1() {
                    return 9
                },
            },
            {
                key: 'TYPES',
                get: function get$$1() {
                    let _ref

                    return (
                        (_ref = {}),
                        defineProperty(_ref, NALU.IDR, 'IDR'),
                        defineProperty(_ref, NALU.SEI, 'SEI'),
                        defineProperty(_ref, NALU.SPS, 'SPS'),
                        defineProperty(_ref, NALU.PPS, 'PPS'),
                        defineProperty(_ref, NALU.NDR, 'NDR'),
                        defineProperty(_ref, NALU.AUD, 'AUD'),
                        _ref
                    )
                },
            },
        ])

        function NALU(data) {
            classCallCheck(this, NALU)

            this.payload = data
            this.nri = (this.payload[0] & 0x60) >> 5
            this.ntype = this.payload[0] & 0x1f
        }

        createClass(NALU, [
            {
                key: 'toString',
                value: function toString() {
                    return `${NALU.type(this)}: NRI: ${this.getNri()}`
                },
            },
            {
                key: 'getNri',
                value: function getNri() {
                    return this.nri >> 6
                },
            },
            {
                key: 'type',
                value: function type() {
                    return this.ntype
                },
            },
            {
                key: 'isKeyframe',
                value: function isKeyframe() {
                    return this.ntype == NALU.IDR
                },
            },
            {
                key: 'getSize',
                value: function getSize() {
                    return 4 + this.payload.byteLength
                },
            },
            {
                key: 'getData',
                value: function getData() {
                    const result = new Uint8Array(this.getSize())
                    const view = new DataView(result.buffer)
                    view.setUint32(0, this.getSize() - 4)

                    result.set(this.payload, 4)
                    return result
                },
            },
        ])
        return NALU
    }())

    /**
     * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
     */

    const ExpGolomb = (function () {
        function ExpGolomb(data) {
            classCallCheck(this, ExpGolomb)

            this.data = data
            this.index = 0
            this.bitLength = data.byteLength * 8
        }

        createClass(ExpGolomb, [
            {
                key: 'skipBits',
                value: function skipBits(size) {
                    // console.log(`  skip bits: size=${size}, ${this.index}.`);
                    if (this.bitsAvailable < size) {
                        // throw new Error('no bytes available');
                        return false
                    }
                    this.index += size
                },
            },
            {
                key: 'readBits',
                value: function readBits(size) {
                    const moveIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true

                    // console.log(`  read bits: size=${size}, ${this.index}.`);
                    const result = this.getBits(size, this.index, moveIndex)
                    // console.log(`    read bits: result=${result}`);
                    return result
                },
            },
            {
                key: 'getBits',
                value: function getBits(size, offsetBits) {
                    const moveIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true

                    if (this.bitsAvailable < size) {
                        // throw new Error('no bytes available');
                        return 0
                    }
                    const offset = offsetBits % 8
                    const byte = this.data[(offsetBits / 8) | 0] & (0xff >>> offset)
                    const bits = 8 - offset
                    if (bits >= size) {
                        if (moveIndex) {
                            this.index += size
                        }
                        return byte >> (bits - size)
                    } 
                        if (moveIndex) {
                            this.index += bits
                        }
                        const nextSize = size - bits
                        return (byte << nextSize) | this.getBits(nextSize, offsetBits + bits, moveIndex)
                },
            },
            {
                key: 'skipLZ',
                value: function skipLZ() {
                    let leadingZeroCount = void 0
                    for (leadingZeroCount = 0; leadingZeroCount < this.bitLength - this.index; ++leadingZeroCount) {
                        if (this.getBits(1, this.index + leadingZeroCount, false) !== 0) {
                            // console.log(`  skip LZ  : size=${leadingZeroCount}, ${this.index}.`);
                            this.index += leadingZeroCount
                            return leadingZeroCount
                        }
                    }
                    return leadingZeroCount
                },
            },
            {
                key: 'skipUEG',
                value: function skipUEG() {
                    this.skipBits(1 + this.skipLZ())
                },
            },
            {
                key: 'skipEG',
                value: function skipEG() {
                    this.skipBits(1 + this.skipLZ())
                },
            },
            {
                key: 'readUEG',
                value: function readUEG() {
                    const prefix = this.skipLZ()
                    return this.readBits(prefix + 1) - 1
                },
            },
            {
                key: 'readEG',
                value: function readEG() {
                    const value = this.readUEG()
                    if (0x01 & value) {
                        // the number is odd if the low order bit is set
                        return (1 + value) >>> 1 // add 1 to make it even, and divide by 2
                    } 
                        return -1 * (value >>> 1) // divide by two then make it negative
                },
            },
            {
                key: 'readBoolean',
                value: function readBoolean() {
                    return this.readBits(1) === 1
                },
            },
            {
                key: 'readUByte',
                value: function readUByte() {
                    const numberOfBytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1

                    return this.readBits(numberOfBytes * 8)
                },
            },
            {
                key: 'readUShort',
                value: function readUShort() {
                    return this.readBits(16)
                },
            },
            {
                key: 'readUInt',
                value: function readUInt() {
                    return this.readBits(32)
                },
            },
            {
                key: 'bitsAvailable',
                get: function get$$1() {
                    return this.bitLength - this.index
                },
            },
        ])
        return ExpGolomb
    }())

    const H264Parser = (function () {
        createClass(H264Parser, null, [
            {
                key: 'extractNALu',
                value: function extractNALu(buffer) {
                    let i = 0;
                        const length = buffer.byteLength;
                        let value = void 0;
                        let state = 0;
                        const result = [];
                        let lastIndex = void 0

                    while (i < length) {
                        value = buffer[i++]
                        switch (state) {
                            case 0:
                                if (value === 0) {
                                    state = 1
                                }
                                break
                            case 1:
                                if (value === 0) {
                                    state = 2
                                } else {
                                    state = 0
                                }
                                break
                            case 2:
                            case 3:
                                if (value === 0) {
                                    state = 3
                                } else if (value === 1 && i < length) {
                                    if (lastIndex) {
                                        result.push(buffer.subarray(lastIndex, i - state - 1))
                                    }
                                    lastIndex = i
                                    state = 0
                                } else {
                                    state = 0
                                }
                                break
                            default:
                                break
                        }
                    }

                    if (lastIndex) {
                        result.push(buffer.subarray(lastIndex, length))
                    }
                    return result
                },

                /**
                 * Advance the ExpGolomb decoder past a scaling list. The scaling
                 * list is optionally transmitted as part of a sequence parameter
                 * set and is not relevant to transmuxing.
                 * @param decoder {ExpGolomb} exp golomb decoder
                 * @param count {number} the number of entries in this scaling list
                 * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
                 */
            },
            {
                key: 'skipScalingList',
                value: function skipScalingList(decoder, count) {
                    let lastScale = 8;
                        let nextScale = 8;
                        let deltaScale = void 0
                    for (let j = 0; j < count; j++) {
                        if (nextScale !== 0) {
                            deltaScale = decoder.readEG()
                            nextScale = (lastScale + deltaScale + 256) % 256
                        }
                        lastScale = nextScale === 0 ? lastScale : nextScale
                    }
                },

                /**
                 * Read a sequence parameter set and return some interesting video
                 * properties. A sequence parameter set is the H264 metadata that
                 * describes the properties of upcoming video frames.
                 * @param data {Uint8Array} the bytes of a sequence parameter set
                 * @return {object} an object with configuration parsed from the
                 * sequence parameter set, including the dimensions of the
                 * associated video frames.
                 */
            },
            {
                key: 'readSPS',
                value: function readSPS(data) {
                    const decoder = new ExpGolomb(data)
                    let frameCropLeftOffset = 0;
                        let frameCropRightOffset = 0;
                        let frameCropTopOffset = 0;
                        let frameCropBottomOffset = 0;
                        let sarScale = 1;
                        let profileIdc = void 0;
                        let profileCompat = void 0;
                        let levelIdc = void 0;
                        let numRefFramesInPicOrderCntCycle = void 0;
                        let picWidthInMbsMinus1 = void 0;
                        let picHeightInMapUnitsMinus1 = void 0;
                        let frameMbsOnlyFlag = void 0;
                        let scalingListCount = void 0
                    decoder.readUByte()
                    profileIdc = decoder.readUByte() // profile_idc
                    profileCompat = decoder.readBits(5) // constraint_set[0-4]_flag, u(5)
                    decoder.skipBits(3) // reserved_zero_3bits u(3),
                    levelIdc = decoder.readUByte() // level_idc u(8)
                    decoder.skipUEG() // seq_parameter_set_id
                    // some profiles have more optional data we don't need
                    if (
                        profileIdc === 100
                        || profileIdc === 110
                        || profileIdc === 122
                        || profileIdc === 244
                        || profileIdc === 44
                        || profileIdc === 83
                        || profileIdc === 86
                        || profileIdc === 118
                        || profileIdc === 128
                    ) {
                        const chromaFormatIdc = decoder.readUEG()
                        if (chromaFormatIdc === 3) {
                            decoder.skipBits(1) // separate_colour_plane_flag
                        }
                        decoder.skipUEG() // bit_depth_luma_minus8
                        decoder.skipUEG() // bit_depth_chroma_minus8
                        decoder.skipBits(1) // qpprime_y_zero_transform_bypass_flag
                        if (decoder.readBoolean()) {
                            // seq_scaling_matrix_present_flag
                            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12
                            for (let i = 0; i < scalingListCount; ++i) {
                                if (decoder.readBoolean()) {
                                    // seq_scaling_list_present_flag[ i ]
                                    if (i < 6) {
                                        H264Parser.skipScalingList(decoder, 16)
                                    } else {
                                        H264Parser.skipScalingList(decoder, 64)
                                    }
                                }
                            }
                        }
                    }
                    decoder.skipUEG() // log2_max_frame_num_minus4
                    const picOrderCntType = decoder.readUEG()
                    if (picOrderCntType === 0) {
                        decoder.readUEG() // log2_max_pic_order_cnt_lsb_minus4
                    } else if (picOrderCntType === 1) {
                        decoder.skipBits(1) // delta_pic_order_always_zero_flag
                        decoder.skipEG() // offset_for_non_ref_pic
                        decoder.skipEG() // offset_for_top_to_bottom_field
                        numRefFramesInPicOrderCntCycle = decoder.readUEG()
                        for (let _i = 0; _i < numRefFramesInPicOrderCntCycle; ++_i) {
                            decoder.skipEG() // offset_for_ref_frame[ i ]
                        }
                    }
                    decoder.skipUEG() // max_num_ref_frames
                    decoder.skipBits(1) // gaps_in_frame_num_value_allowed_flag
                    picWidthInMbsMinus1 = decoder.readUEG()
                    picHeightInMapUnitsMinus1 = decoder.readUEG()
                    frameMbsOnlyFlag = decoder.readBits(1)
                    if (frameMbsOnlyFlag === 0) {
                        decoder.skipBits(1) // mb_adaptive_frame_field_flag
                    }
                    decoder.skipBits(1) // direct_8x8_inference_flag
                    if (decoder.readBoolean()) {
                        // frame_cropping_flag
                        frameCropLeftOffset = decoder.readUEG()
                        frameCropRightOffset = decoder.readUEG()
                        frameCropTopOffset = decoder.readUEG()
                        frameCropBottomOffset = decoder.readUEG()
                    }
                    if (decoder.readBoolean()) {
                        // vui_parameters_present_flag
                        if (decoder.readBoolean()) {
                            // aspect_ratio_info_present_flag
                            let sarRatio = void 0
                            const aspectRatioIdc = decoder.readUByte()
                            switch (aspectRatioIdc) {
                                case 1:
                                    sarRatio = [1, 1]
                                    break
                                case 2:
                                    sarRatio = [12, 11]
                                    break
                                case 3:
                                    sarRatio = [10, 11]
                                    break
                                case 4:
                                    sarRatio = [16, 11]
                                    break
                                case 5:
                                    sarRatio = [40, 33]
                                    break
                                case 6:
                                    sarRatio = [24, 11]
                                    break
                                case 7:
                                    sarRatio = [20, 11]
                                    break
                                case 8:
                                    sarRatio = [32, 11]
                                    break
                                case 9:
                                    sarRatio = [80, 33]
                                    break
                                case 10:
                                    sarRatio = [18, 11]
                                    break
                                case 11:
                                    sarRatio = [15, 11]
                                    break
                                case 12:
                                    sarRatio = [64, 33]
                                    break
                                case 13:
                                    sarRatio = [160, 99]
                                    break
                                case 14:
                                    sarRatio = [4, 3]
                                    break
                                case 15:
                                    sarRatio = [3, 2]
                                    break
                                case 16:
                                    sarRatio = [2, 1]
                                    break
                                case 255: {
                                    sarRatio = [
                                        (decoder.readUByte() << 8) | decoder.readUByte(),
                                        (decoder.readUByte() << 8) | decoder.readUByte(),
                                    ]
                                    break
                                }
                            }
                            if (sarRatio) {
                                sarScale = sarRatio[0] / sarRatio[1]
                            }
                        }
                        if (decoder.readBoolean()) {
                            decoder.skipBits(1)
                        }

                        if (decoder.readBoolean()) {
                            decoder.skipBits(4)
                            if (decoder.readBoolean()) {
                                decoder.skipBits(24)
                            }
                        }
                        if (decoder.readBoolean()) {
                            decoder.skipUEG()
                            decoder.skipUEG()
                        }
                        if (decoder.readBoolean()) {
                            const unitsInTick = decoder.readUInt()
                            const timeScale = decoder.readUInt()
                            const fixedFrameRate = decoder.readBoolean()
                        }
                    }
                    return {
                        width: Math.ceil(
                            ((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2)
                                * sarScale,
                        ),
                        height:
                            (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16
                            - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
                    }
                },
            },
        ])

        function H264Parser(remuxer) {
            classCallCheck(this, H264Parser)

            this.remuxer = remuxer
            this.track = remuxer.mp4track
        }

        createClass(H264Parser, [
            {
                key: 'parseSPS',
                value: function parseSPS(sps) {
                    const config = H264Parser.readSPS(new Uint8Array(sps))

                    this.track.width = config.width
                    this.track.height = config.height
                    this.track.sps = [new Uint8Array(sps)]
                    this.track.codec = 'avc1.'

                    const codecarray = new DataView(sps.buffer, sps.byteOffset + 1, 4)
                    for (let i = 0; i < 3; ++i) {
                        let h = codecarray.getUint8(i).toString(16)
                        if (h.length < 2) {
                            h = `0${h}`
                        }
                        this.track.codec += h
                    }
                },
            },
            {
                key: 'parsePPS',
                value: function parsePPS(pps) {
                    this.track.pps = [new Uint8Array(pps)]
                },
            },
            {
                key: 'parseNAL',
                value: function parseNAL(unit) {
                    if (!unit) return false
                    let push = false
                    switch (unit.type()) {
                        case NALU.NDR:
                            push = true
                            break
                        case NALU.IDR:
                            push = true
                            break
                        case NALU.PPS:
                            if (!this.track.pps) {
                                this.parsePPS(unit.getData().subarray(4))
                                if (!this.remuxer.readyToDecode && this.track.pps && this.track.sps) {
                                    this.remuxer.readyToDecode = true
                                }
                            }
                            push = true
                            break
                        case NALU.SPS:
                            if (!this.track.sps) {
                                this.parseSPS(unit.getData().subarray(4))
                                if (!this.remuxer.readyToDecode && this.track.pps && this.track.sps) {
                                    this.remuxer.readyToDecode = true
                                }
                            }
                            push = true
                            break
                        case NALU.AUD:
                            console.log('AUD - ignoing and disable HD mode for live channel')
                            if (this.remuxer.isHDAvail) {
                                this.remuxer.isHDAvail = false
                            }
                            break
                        case NALU.SEI:
                            // console.log('SEI - ignoing');
                            break
                        default:
                    }
                    return push
                },
            },
        ])
        return H264Parser
    }())

    let aacHeader = void 0
    const AACParser = (function () {
        createClass(AACParser, null, [
            {
                key: 'getHeaderLength',
                value: function getHeaderLength(data) {
                    return data[1] & 0x01 ? 7 : 9 // without CRC 7 and with CRC 9 Refs: https://wiki.multimedia.cx/index.php?title=ADTS
                },
            },
            {
                key: 'getFrameLength',
                value: function getFrameLength(data) {
                    return ((data[3] & 0x03) << 11) | (data[4] << 3) | ((data[5] & 0xe0) >>> 5) // 13 bits length ref: https://wiki.multimedia.cx/index.php?title=ADTS
                },
            },
            {
                key: 'isAACPattern',
                value: function isAACPattern(data) {
                    return data[0] === 0xff && (data[1] & 0xf0) === 0xf0 && (data[1] & 0x06) === 0x00
                },
            },
            {
                key: 'extractAAC',
                value: function extractAAC(buffer) {
                    let i = 0;
                        const length = buffer.byteLength;
                        const result = [];
                        let headerLength = void 0;
                        let frameLength = void 0

                    if (!AACParser.isAACPattern(buffer)) {
                        console.error('Invalid ADTS audio format')
                        return result
                    }
                    headerLength = AACParser.getHeaderLength(buffer)
                    if (!aacHeader) {
                        aacHeader = buffer.subarray(0, headerLength)
                    }

                    while (i < length) {
                        frameLength = AACParser.getFrameLength(buffer)
                        result.push(buffer.subarray(headerLength, frameLength))
                        buffer = buffer.slice(frameLength)
                        i += frameLength
                    }
                    return result
                },
            },
            {
                key: 'samplingRateMap',
                get: function get$$1() {
                    return [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]
                },
            },
            {
                key: 'getAACHeaderData',
                get: function get$$1() {
                    return aacHeader
                },
            },
        ])

        function AACParser(remuxer) {
            classCallCheck(this, AACParser)

            this.remuxer = remuxer
            this.track = remuxer.mp4track
        }

        createClass(AACParser, [
            {
                key: 'setAACConfig',
                value: function setAACConfig() {
                    let objectType = void 0;
                        let sampleIndex = void 0;
                        let channelCount = void 0;
                        const config = new Uint8Array(2);
                        const headerData = AACParser.getAACHeaderData

                    if (!headerData) return

                    objectType = ((headerData[2] & 0xc0) >>> 6) + 1
                    sampleIndex = (headerData[2] & 0x3c) >>> 2
                    channelCount = (headerData[2] & 0x01) << 2
                    channelCount |= (headerData[3] & 0xc0) >>> 6

                    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config */
                    config[0] = objectType << 3
                    config[0] |= (sampleIndex & 0x0e) >> 1
                    config[1] |= (sampleIndex & 0x01) << 7
                    config[1] |= channelCount << 3

                    this.track.codec = `mp4a.40.${objectType}`
                    this.track.channelCount = channelCount
                    this.track.config = config
                    this.remuxer.readyToDecode = true
                },
            },
        ])
        return AACParser
    }())

    const Event = (function () {
        function Event(type) {
            classCallCheck(this, Event)

            this.listener = {}
            this.type = type | ''
        }

        createClass(Event, [
            {
                key: 'on',
                value: function on(event, fn) {
                    if (!this.listener[event]) {
                        this.listener[event] = []
                    }
                    this.listener[event].push(fn)
                    return true
                },
            },
            {
                key: 'off',
                value: function off(event, fn) {
                    if (this.listener[event]) {
                        const index = this.listener[event].indexOf(fn)
                        if (index > -1) {
                            this.listener[event].splice(index, 1)
                        }
                        return true
                    }
                    return false
                },
            },
            {
                key: 'offAll',
                value: function offAll() {
                    this.listener = {}
                },
            },
            {
                key: 'dispatch',
                value: function dispatch(event, data) {
                    if (this.listener[event]) {
                        this.listener[event].map((each) => {
                            each.apply(null, [data])
                        })
                        return true
                    }
                    return false
                },
            },
        ])
        return Event
    }())

    /**
     * Generate MP4 Box
     * taken from: https://github.com/dailymotion/hls.js
     */

    const MP4 = (function () {
        function MP4() {
            classCallCheck(this, MP4)
        }

        createClass(MP4, null, [
            {
                key: 'init',
                value: function init() {
                    MP4.types = {
                        avc1: [], // codingname
                        avcC: [],
                        btrt: [],
                        dinf: [],
                        dref: [],
                        esds: [],
                        ftyp: [],
                        hdlr: [],
                        mdat: [],
                        mdhd: [],
                        mdia: [],
                        mfhd: [],
                        minf: [],
                        moof: [],
                        moov: [],
                        mp4a: [],
                        mvex: [],
                        mvhd: [],
                        sdtp: [],
                        stbl: [],
                        stco: [],
                        stsc: [],
                        stsd: [],
                        stsz: [],
                        stts: [],
                        tfdt: [],
                        tfhd: [],
                        traf: [],
                        trak: [],
                        trun: [],
                        trex: [],
                        tkhd: [],
                        vmhd: [],
                        smhd: [],
                    }

                    let i
                    for (i in MP4.types) {
                        if (MP4.types.hasOwnProperty(i)) {
                            MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)]
                        }
                    }

                    const videoHdlr = new Uint8Array([
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x00, // pre_defined
                        0x76,
                        0x69,
                        0x64,
                        0x65, // handler_type: 'vide'
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x56,
                        0x69,
                        0x64,
                        0x65,
                        0x6f,
                        0x48,
                        0x61,
                        0x6e,
                        0x64,
                        0x6c,
                        0x65,
                        0x72,
                        0x00,
                    ])

                    const audioHdlr = new Uint8Array([
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x00, // pre_defined
                        0x73,
                        0x6f,
                        0x75,
                        0x6e, // handler_type: 'soun'
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x53,
                        0x6f,
                        0x75,
                        0x6e,
                        0x64,
                        0x48,
                        0x61,
                        0x6e,
                        0x64,
                        0x6c,
                        0x65,
                        0x72,
                        0x00,
                    ])

                    MP4.HDLR_TYPES = {
                        video: videoHdlr,
                        audio: audioHdlr,
                    }

                    const dref = new Uint8Array([
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x01, // entry_count
                        0x00,
                        0x00,
                        0x00,
                        0x0c, // entry_size
                        0x75,
                        0x72,
                        0x6c,
                        0x20, // 'url' type
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x01,
                    ])

                    const stco = new Uint8Array([
                        0x00, // version
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                    ])

                    MP4.STTS = MP4.STSC = MP4.STCO = stco

                    MP4.STSZ = new Uint8Array([
                        0x00, // version
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x00, // sample_size
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                    ])
                    MP4.VMHD = new Uint8Array([
                        0x00, // version
                        0x00,
                        0x00,
                        0x01, // flags
                        0x00,
                        0x00, // graphicsmode
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                    ])
                    MP4.SMHD = new Uint8Array([
                        0x00, // version
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00, // balance
                        0x00,
                        0x00,
                    ])

                    MP4.STSD = new Uint8Array([
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                    ]) // entry_count

                    const majorBrand = new Uint8Array([105, 115, 111, 109]) // isom
                    const avc1Brand = new Uint8Array([97, 118, 99, 49]) // avc1
                    const minorVersion = new Uint8Array([0, 0, 0, 1])

                    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand)
                    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref))
                },
            },
            {
                key: 'box',
                value: function box(type) {
                    for (
                        var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1;
                        _key < _len;
                        _key++
                    ) {
                        payload[_key - 1] = arguments[_key]
                    }

                    let size = 8;
                        let i = payload.length;
                        const len = i;
                        let result
                    // calculate the total size we need to allocate
                    while (i--) {
                        size += payload[i].byteLength
                    }
                    result = new Uint8Array(size)
                    result[0] = (size >> 24) & 0xff
                    result[1] = (size >> 16) & 0xff
                    result[2] = (size >> 8) & 0xff
                    result[3] = size & 0xff
                    result.set(type, 4)
                    // copy the payload into the result
                    for (i = 0, size = 8; i < len; ++i) {
                        // copy payload[i] array @ offset size
                        result.set(payload[i], size)
                        size += payload[i].byteLength
                    }
                    return result
                },
            },
            {
                key: 'hdlr',
                value: function hdlr(type) {
                    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type])
                },
            },
            {
                key: 'mdat',
                value: function mdat(data) {
                    return MP4.box(MP4.types.mdat, data)
                },
            },
            {
                key: 'mdhd',
                value: function mdhd(timescale, duration) {
                    return MP4.box(
                        MP4.types.mdhd,
                        new Uint8Array([
                            0x00, // version 0
                            0x00,
                            0x00,
                            0x00, // flags
                            0x00,
                            0x00,
                            0x00,
                            0x02, // creation_time
                            0x00,
                            0x00,
                            0x00,
                            0x03, // modification_time
                            (timescale >> 24) & 0xff,
                            (timescale >> 16) & 0xff,
                            (timescale >> 8) & 0xff,
                            timescale & 0xff, // timescale
                            duration >> 24,
                            (duration >> 16) & 0xff,
                            (duration >> 8) & 0xff,
                            duration & 0xff, // duration
                            0x55,
                            0xc4, // 'und' language (undetermined)
                            0x00,
                            0x00,
                        ]),
                    )
                },
            },
            {
                key: 'mdia',
                value: function mdia(track) {
                    return MP4.box(
                        MP4.types.mdia,
                        MP4.mdhd(track.timescale, track.duration),
                        MP4.hdlr(track.type),
                        MP4.minf(track),
                    )
                },
            },
            {
                key: 'mfhd',
                value: function mfhd(sequenceNumber) {
                    return MP4.box(
                        MP4.types.mfhd,
                        new Uint8Array([
                            0x00,
                            0x00,
                            0x00,
                            0x00, // flags
                            sequenceNumber >> 24,
                            (sequenceNumber >> 16) & 0xff,
                            (sequenceNumber >> 8) & 0xff,
                            sequenceNumber & 0xff,
                        ]), // sequence_number
                    )
                },
            },
            {
                key: 'minf',
                value: function minf(track) {
                    if (track.type === 'audio') {
                        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track))
                    } 
                        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track))
                },
            },
            {
                key: 'moof',
                value: function moof(sn, baseMediaDecodeTime, track) {
                    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime))
                },
                /**
                 * @param tracks... (optional) {array} the tracks associated with this movie
                 */
            },
            {
                key: 'moov',
                value: function moov(tracks, duration, timescale) {
                    let i = tracks.length;
                        const boxes = []

                    while (i--) {
                        boxes[i] = MP4.trak(tracks[i])
                    }

                    return MP4.box.apply(
                        null,
                        [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)]
                            .concat(boxes)
                            .concat(MP4.mvex(tracks)),
                    )
                },
            },
            {
                key: 'mvex',
                value: function mvex(tracks) {
                    let i = tracks.length;
                        const boxes = []

                    while (i--) {
                        boxes[i] = MP4.trex(tracks[i])
                    }
                    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes))
                },
            },
            {
                key: 'mvhd',
                value: function mvhd(timescale, duration) {
                    const bytes = new Uint8Array([
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x00, // flags
                        0x00,
                        0x00,
                        0x00,
                        0x01, // creation_time
                        0x00,
                        0x00,
                        0x00,
                        0x02, // modification_time
                        (timescale >> 24) & 0xff,
                        (timescale >> 16) & 0xff,
                        (timescale >> 8) & 0xff,
                        timescale & 0xff, // timescale
                        (duration >> 24) & 0xff,
                        (duration >> 16) & 0xff,
                        (duration >> 8) & 0xff,
                        duration & 0xff, // duration
                        0x00,
                        0x01,
                        0x00,
                        0x00, // 1.0 rate
                        0x01,
                        0x00, // 1.0 volume
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x01,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x40,
                        0x00,
                        0x00,
                        0x00, // transformation: unity matrix
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00, // pre_defined
                        0xff,
                        0xff,
                        0xff,
                        0xff,
                    ])
                    return MP4.box(MP4.types.mvhd, bytes)
                },
            },
            {
                key: 'sdtp',
                value: function sdtp(track) {
                    const samples = track.samples || [];
                        const bytes = new Uint8Array(4 + samples.length);
                        let flags;
                        let i
                    // leave the full box header (4 bytes) all zero
                    // write the sample table
                    for (i = 0; i < samples.length; i++) {
                        flags = samples[i].flags
                        bytes[i + 4] = (flags.dependsOn << 4) | (flags.isDependedOn << 2) | flags.hasRedundancy
                    }

                    return MP4.box(MP4.types.sdtp, bytes)
                },
            },
            {
                key: 'stbl',
                value: function stbl(track) {
                    return MP4.box(
                        MP4.types.stbl,
                        MP4.stsd(track),
                        MP4.box(MP4.types.stts, MP4.STTS),
                        MP4.box(MP4.types.stsc, MP4.STSC),
                        MP4.box(MP4.types.stsz, MP4.STSZ),
                        MP4.box(MP4.types.stco, MP4.STCO),
                    )
                },
            },
            {
                key: 'avc1',
                value: function avc1(track) {
                    let sps = [];
                        let pps = [];
                        let i;
                        let data;
                        let len
                    // assemble the SPSs

                    for (i = 0; i < track.sps.length; i++) {
                        data = track.sps[i]
                        len = data.byteLength
                        sps.push((len >>> 8) & 0xff)
                        sps.push(len & 0xff)
                        sps = sps.concat(Array.prototype.slice.call(data)) // SPS
                    }

                    // assemble the PPSs
                    for (i = 0; i < track.pps.length; i++) {
                        data = track.pps[i]
                        len = data.byteLength
                        pps.push((len >>> 8) & 0xff)
                        pps.push(len & 0xff)
                        pps = pps.concat(Array.prototype.slice.call(data))
                    }

                    const avcc = MP4.box(
                            MP4.types.avcC,
                            new Uint8Array(
                                [
                                    0x01, // version
                                    sps[3], // profile
                                    sps[4], // profile compat
                                    sps[5], // level
                                    0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
                                    0xe0 | track.sps.length,
                                ]
                                    .concat(sps)
                                    .concat(
                                        [track.pps.length], // numOfPictureParameterSets
                                    )
                                    .concat(pps),
                            ),
                        );
                        // "PPS"
                        const { width } = track;
                        const { height } = track
                    // console.log('avcc:' + Hex.hexDump(avcc));
                    return MP4.box(
                        MP4.types.avc1,
                        new Uint8Array([
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x01, // data_reference_index
                            0x00,
                            0x00, // pre_defined
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00, // pre_defined
                            (width >> 8) & 0xff,
                            width & 0xff, // width
                            (height >> 8) & 0xff,
                            height & 0xff, // height
                            0x00,
                            0x48,
                            0x00,
                            0x00, // horizresolution
                            0x00,
                            0x48,
                            0x00,
                            0x00, // vertresolution
                            0x00,
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x01, // frame_count
                            0x12,
                            0x62,
                            0x69,
                            0x6e,
                            0x65, // binelpro.ru
                            0x6c,
                            0x70,
                            0x72,
                            0x6f,
                            0x2e,
                            0x72,
                            0x75,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00, // compressorname
                            0x00,
                            0x18, // depth = 24
                            0x11,
                            0x11,
                        ]), // pre_defined = -1
                        avcc,
                        MP4.box(
                            MP4.types.btrt,
                            new Uint8Array([
                                0x00,
                                0x1c,
                                0x9c,
                                0x80, // bufferSizeDB
                                0x00,
                                0x2d,
                                0xc6,
                                0xc0, // maxBitrate
                                0x00,
                                0x2d,
                                0xc6,
                                0xc0,
                            ]),
                        ), // avgBitrate
                    )
                },
            },
            {
                key: 'esds',
                value: function esds(track) {
                    const configlen = track.config.byteLength
                    const data = new Uint8Array(26 + configlen + 3)
                    data.set([
                        0x00, // version 0
                        0x00,
                        0x00,
                        0x00, // flags

                        0x03, // descriptor_type
                        0x17 + configlen, // length
                        0x00,
                        0x01, // es_id
                        0x00, // stream_priority

                        0x04, // descriptor_type
                        0x0f + configlen, // length
                        0x40, // codec : mpeg4_audio
                        0x15, // stream_type
                        0x00,
                        0x00,
                        0x00, // buffer_size
                        0x00,
                        0x00,
                        0x00,
                        0x00, // maxBitrate
                        0x00,
                        0x00,
                        0x00,
                        0x00, // avgBitrate

                        0x05, // descriptor_type
                        configlen,
                    ])
                    data.set(track.config, 26)
                    data.set([0x06, 0x01, 0x02], 26 + configlen)
                    // return new Uint8Array([
                    //     0x00, // version 0
                    //     0x00, 0x00, 0x00, // flags
                    //
                    //     0x03, // descriptor_type
                    //     0x17+configlen, // length
                    //     0x00, 0x01, //es_id
                    //     0x00, // stream_priority
                    //
                    //     0x04, // descriptor_type
                    //     0x0f+configlen, // length
                    //     0x40, //codec : mpeg4_audio
                    //     0x15, // stream_type
                    //     0x00, 0x00, 0x00, // buffer_size
                    //     0x00, 0x00, 0x00, 0x00, // maxBitrate
                    //     0x00, 0x00, 0x00, 0x00, // avgBitrate
                    //
                    //     0x05 // descriptor_type
                    // ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
                    return data
                },
            },
            {
                key: 'mp4a',
                value: function mp4a(track) {
                    const { audiosamplerate } = track
                    return MP4.box(
                        MP4.types.mp4a,
                        new Uint8Array([
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x01, // data_reference_index
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            track.channelCount, // channelcount
                            0x00,
                            0x10, // sampleSize:16bits
                            0x00,
                            0x00, // pre_defined
                            0x00,
                            0x00, // reserved2
                            (audiosamplerate >> 8) & 0xff,
                            audiosamplerate & 0xff, //
                            0x00,
                            0x00,
                        ]),
                        MP4.box(MP4.types.esds, MP4.esds(track)),
                    )
                },
            },
            {
                key: 'stsd',
                value: function stsd(track) {
                    if (track.type === 'audio') {
                        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track))
                    } 
                        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track))
                },
            },
            {
                key: 'tkhd',
                value: function tkhd(track) {
                    const { id } = track;
                        const { duration } = track;
                        const { width } = track;
                        const { height } = track;
                        const { volume } = track
                    return MP4.box(
                        MP4.types.tkhd,
                        new Uint8Array([
                            0x00, // version 0
                            0x00,
                            0x00,
                            0x07, // flags
                            0x00,
                            0x00,
                            0x00,
                            0x00, // creation_time
                            0x00,
                            0x00,
                            0x00,
                            0x00, // modification_time
                            (id >> 24) & 0xff,
                            (id >> 16) & 0xff,
                            (id >> 8) & 0xff,
                            id & 0xff, // track_ID
                            0x00,
                            0x00,
                            0x00,
                            0x00, // reserved
                            duration >> 24,
                            (duration >> 16) & 0xff,
                            (duration >> 8) & 0xff,
                            duration & 0xff, // duration
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x00, // layer
                            0x00,
                            0x00, // alternate_group
                            (volume >> 0) & 0xff,
                            (((volume % 1) * 10) >> 0) & 0xff, // track volume // FIXME
                            0x00,
                            0x00, // reserved
                            0x00,
                            0x01,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x01,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x40,
                            0x00,
                            0x00,
                            0x00, // transformation: unity matrix
                            (width >> 8) & 0xff,
                            width & 0xff,
                            0x00,
                            0x00, // width
                            (height >> 8) & 0xff,
                            height & 0xff,
                            0x00,
                            0x00,
                        ]), // height
                    )
                },
            },
            {
                key: 'traf',
                value: function traf(track, baseMediaDecodeTime) {
                    const sampleDependencyTable = MP4.sdtp(track);
                        const { id } = track
                    return MP4.box(
                        MP4.types.traf,
                        MP4.box(
                            MP4.types.tfhd,
                            new Uint8Array([
                                0x00, // version 0
                                0x00,
                                0x00,
                                0x00, // flags
                                id >> 24,
                                (id >> 16) & 0xff,
                                (id >> 8) & 0xff,
                                id & 0xff,
                            ]), // track_ID
                        ),
                        MP4.box(
                            MP4.types.tfdt,
                            new Uint8Array([
                                0x00, // version 0
                                0x00,
                                0x00,
                                0x00, // flags
                                baseMediaDecodeTime >> 24,
                                (baseMediaDecodeTime >> 16) & 0xff,
                                (baseMediaDecodeTime >> 8) & 0xff,
                                baseMediaDecodeTime & 0xff,
                            ]), // baseMediaDecodeTime
                        ),
                        MP4.trun(
                            track,
                            sampleDependencyTable.length
                                + 16 // tfhd
                                + 16 // tfdt
                                + 8 // traf header
                                + 16 // mfhd
                                + 8 // moof header
                                + 8,
                        ), // mdat header
                        sampleDependencyTable,
                    )
                },

                /**
                 * Generate a track box.
                 * @param track {object} a track definition
                 * @return {Uint8Array} the track box
                 */
            },
            {
                key: 'trak',
                value: function trak(track) {
                    track.duration = track.duration || 0xffffffff
                    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track))
                },
            },
            {
                key: 'trex',
                value: function trex(track) {
                    const { id } = track
                    return MP4.box(
                        MP4.types.trex,
                        new Uint8Array([
                            0x00, // version 0
                            0x00,
                            0x00,
                            0x00, // flags
                            id >> 24,
                            (id >> 16) & 0xff,
                            (id >> 8) & 0xff,
                            id & 0xff, // track_ID
                            0x00,
                            0x00,
                            0x00,
                            0x01, // default_sample_description_index
                            0x00,
                            0x00,
                            0x00,
                            0x00, // default_sample_duration
                            0x00,
                            0x00,
                            0x00,
                            0x00, // default_sample_size
                            0x00,
                            0x01,
                            0x00,
                            0x01,
                        ]), // default_sample_flags
                    )
                },
            },
            {
                key: 'trun',
                value: function trun(track, offset) {
                    const samples = track.samples || [];
                        const len = samples.length;
                        const arraylen = 12 + 16 * len;
                        const array = new Uint8Array(arraylen);
                        let i;
                        let sample;
                        let duration;
                        let size;
                        let flags;
                        let cts
                    offset += 8 + arraylen
                    array.set(
                        [
                            0x00, // version 0
                            0x00,
                            0x0f,
                            0x01, // flags
                            (len >>> 24) & 0xff,
                            (len >>> 16) & 0xff,
                            (len >>> 8) & 0xff,
                            len & 0xff, // sample_count
                            (offset >>> 24) & 0xff,
                            (offset >>> 16) & 0xff,
                            (offset >>> 8) & 0xff,
                            offset & 0xff,
                        ],
                        0,
                    )
                    for (i = 0; i < len; i++) {
                        sample = samples[i]
                        duration = sample.duration
                        size = sample.size
                        flags = sample.flags
                        cts = sample.cts
                        array.set(
                            [
                                (duration >>> 24) & 0xff,
                                (duration >>> 16) & 0xff,
                                (duration >>> 8) & 0xff,
                                duration & 0xff, // sample_duration
                                (size >>> 24) & 0xff,
                                (size >>> 16) & 0xff,
                                (size >>> 8) & 0xff,
                                size & 0xff, // sample_size
                                (flags.isLeading << 2) | flags.dependsOn,
                                (flags.isDependedOn << 6)
                                    | (flags.hasRedundancy << 4)
                                    | (flags.paddingValue << 1)
                                    | flags.isNonSync,
                                flags.degradPrio & (0xf0 << 8),
                                flags.degradPrio & 0x0f, // sample_flags
                                (cts >>> 24) & 0xff,
                                (cts >>> 16) & 0xff,
                                (cts >>> 8) & 0xff,
                                cts & 0xff,
                            ],
                            12 + 16 * i,
                        )
                    }
                    return MP4.box(MP4.types.trun, array)
                },
            },
            {
                key: 'initSegment',
                value: function initSegment(tracks, duration, timescale) {
                    if (!MP4.types) {
                        MP4.init()
                    }
                    const movie = MP4.moov(tracks, duration, timescale);
                        let result
                    result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength)
                    result.set(MP4.FTYP)
                    result.set(movie, MP4.FTYP.byteLength)
                    return result
                },
            },
        ])
        return MP4
    }())

    let track_id = 1
    const BaseRemuxer = (function () {
        createClass(BaseRemuxer, null, [
            {
                key: 'getTrackID',
                value: function getTrackID() {
                    return track_id++
                },
            },
        ])

        function BaseRemuxer() {
            classCallCheck(this, BaseRemuxer)

            this.seq = 1
        }

        createClass(BaseRemuxer, [
            {
                key: 'flush',
                value: function flush() {
                    this.seq++
                    this.mp4track.len = 0
                    this.mp4track.samples = []
                },
            },
            {
                key: 'isReady',
                value: function isReady() {
                    if (!this.readyToDecode || !this.samples.length) return null
                    return true
                },
            },
        ])
        return BaseRemuxer
    }())

    const AACRemuxer = (function (_BaseRemuxer) {
        inherits(AACRemuxer, _BaseRemuxer)

        function AACRemuxer() {
            classCallCheck(this, AACRemuxer)

            const _this = possibleConstructorReturn(
                this,
                (AACRemuxer.__proto__ || Object.getPrototypeOf(AACRemuxer)).call(this),
            )

            _this.readyToDecode = false
            _this.nextDts = 0
            _this.dts = 0
            _this.timescale = 1000000

            _this.mp4track = {
                id: BaseRemuxer.getTrackID(),
                type: 'audio',
                channelCount: 0,
                len: 0,
                fragmented: true,
                timescale: _this.timescale,
                duration: _this.timescale,
                samples: [],
                config: '',
                codec: '',
            }

            _this.samples = []
            _this.aac = new AACParser(_this)
            return _this
        }

        createClass(AACRemuxer, [
            {
                key: 'resetTrack',
                value: function resetTrack() {
                    this.readyToDecode = false
                    this.mp4track.codec = ''
                    this.mp4track.channelCount = ''
                    this.mp4track.config = ''
                    this.mp4track.timescale = this.timescale
                },
            },
            {
                key: 'remux',
                value: function remux(samples) {
                    let size = void 0;
                        let payload = void 0
                    let _iteratorNormalCompletion = true
                    let _didIteratorError = false
                    let _iteratorError

                    try {
                        for (
                            var _iterator = samples[Symbol.iterator](), _step;
                            !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                            _iteratorNormalCompletion = true
                        ) {
                            const _sample = _step.value

                            payload = _sample.units
                            size = payload.byteLength
                            this.samples.push({
                                units: payload,
                                size,
                                duration: _sample.duration,
                            })
                            this.mp4track.len += size
                            if (!this.readyToDecode) {
                                this.aac.setAACConfig()
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true
                        _iteratorError = err
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return()
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError
                            }
                        }
                    }
                },
            },
            {
                key: 'getPayload',
                value: function getPayload() {
                    if (!this.isReady()) {
                        return null
                    }

                    const payload = new Uint8Array(this.mp4track.len)
                    let offset = 0
                    const { samples } = this.mp4track
                    let mp4Sample = void 0;
                        let duration = void 0

                    this.dts = this.nextDts

                    while (this.samples.length) {
                        const sample = this.samples.shift();
                            const { units } = sample

                        duration = sample.duration

                        if (duration <= 0) {
                            console.log(`remuxer: invalid sample duration at DTS: ${this.nextDts}:${duration}`)
                            this.mp4track.len -= sample.size
                            continue
                        }

                        this.nextDts += duration
                        mp4Sample = {
                            size: sample.size,
                            duration,
                            cts: 0,
                            flags: {
                                isLeading: 0,
                                isDependedOn: 0,
                                hasRedundancy: 0,
                                degradPrio: 0,
                                dependsOn: 1,
                            },
                        }

                        payload.set(sample.units, offset)
                        offset += sample.size
                        samples.push(mp4Sample)
                    }

                    if (!samples.length) return null

                    return new Uint8Array(payload.buffer, 0, this.mp4track.len)
                },
            },
        ])
        return AACRemuxer
    }(BaseRemuxer))

    const H264Remuxer = (function (_BaseRemuxer) {
        inherits(H264Remuxer, _BaseRemuxer)

        function H264Remuxer() {
            classCallCheck(this, H264Remuxer)

            const _this = possibleConstructorReturn(
                this,
                (H264Remuxer.__proto__ || Object.getPrototypeOf(H264Remuxer)).call(this),
            )

            _this.readyToDecode = false
            _this.nextDts = 0
            _this.dts = 0
            _this.timescale = 1000000

            _this.mp4track = {
                id: BaseRemuxer.getTrackID(),
                type: 'video',
                len: 0,
                fragmented: true,
                sps: '',
                pps: '',
                width: 3840,
                height: 2610,
                timescale: _this.timescale,
                duration: _this.timescale,
                samples: [],
            }

            _this.samples = []
            _this.h264 = new H264Parser(_this)
            return _this
        }

        createClass(H264Remuxer, [
            {
                key: 'resetTrack',
                value: function resetTrack() {
                    this.readyToDecode = false
                    this.mp4track.sps = ''
                    this.mp4track.pps = ''
                },
            },
            {
                key: 'remux',
                value: function remux(samples) {
                    let sample = void 0;
                        let units = void 0;
                        let unit = void 0;
                        let size = void 0;
                        let keyFrame = void 0
                    let _iteratorNormalCompletion = true
                    let _didIteratorError = false
                    let _iteratorError

                    try {
                        for (
                            var _iterator = samples[Symbol.iterator](), _step;
                            !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                            _iteratorNormalCompletion = true
                        ) {
                            sample = _step.value

                            units = []
                            size = 0
                            keyFrame = false
                            let _iteratorNormalCompletion2 = true
                            let _didIteratorError2 = false
                            let _iteratorError2

                            try {
                                for (
                                    var _iterator2 = sample.units[Symbol.iterator](), _step2;
                                    !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
                                    _iteratorNormalCompletion2 = true
                                ) {
                                    unit = _step2.value
                                    if (size == 0 && unit.getSize() == 4) {
                                        // Web-Live View-Camera ListIPCPrimaryIPChttps://www.tapd.cn/21417271/bugtrace/bugs/view?bug_id=1121417271001068764
                                        console.log(`nal:${unit.type()} byteLength:${unit.getSize()}`)
                                        break
                                    }
                                    if (this.h264.parseNAL(unit)) {
                                        units.push(unit)
                                        size += unit.getSize()

                                        if (!keyFrame) {
                                            keyFrame = unit.isKeyframe()
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true
                                _iteratorError2 = err
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return()
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2
                                    }
                                }
                            }

                            if (units.length > 0 && this.readyToDecode) {
                                this.mp4track.len += size
                                this.samples.push({
                                    units,
                                    size,
                                    keyFrame,
                                    duration: sample.duration,
                                })
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true
                        _iteratorError = err
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return()
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError
                            }
                        }
                    }
                },
            },
            {
                key: 'getPayload',
                value: function getPayload() {
                    if (!this.isReady()) {
                        return null
                    }

                    const payload = new Uint8Array(this.mp4track.len)
                    let offset = 0
                    const { samples } = this.mp4track
                    let mp4Sample = void 0;
                        let duration = void 0

                    this.dts = this.nextDts

                    while (this.samples.length) {
                        const sample = this.samples.shift();
                            const { units } = sample

                        duration = sample.duration

                        if (duration <= 0) {
                            console.log(`remuxer: invalid sample duration at DTS: ${this.nextDts}:${duration}`)
                            this.mp4track.len -= sample.size
                            continue
                        }

                        this.nextDts += duration
                        mp4Sample = {
                            size: sample.size,
                            duration,
                            cts: 0,
                            flags: {
                                isLeading: 0,
                                isDependedOn: 0,
                                hasRedundancy: 0,
                                degradPrio: 0,
                                isNonSync: sample.keyFrame ? 0 : 1,
                                dependsOn: sample.keyFrame ? 2 : 1,
                            },
                        }

                        let _iteratorNormalCompletion3 = true
                        let _didIteratorError3 = false
                        let _iteratorError3

                        try {
                            for (
                                var _iterator3 = units[Symbol.iterator](), _step3;
                                !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done);
                                _iteratorNormalCompletion3 = true
                            ) {
                                const unit = _step3.value

                                payload.set(unit.getData(), offset)
                                offset += unit.getSize()
                            }
                        } catch (err) {
                            _didIteratorError3 = true
                            _iteratorError3 = err
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                    _iterator3.return()
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3
                                }
                            }
                        }

                        samples.push(mp4Sample)
                    }

                    if (!samples.length) return null
                    return new Uint8Array(payload.buffer, 0, this.mp4track.len)
                },
            },
        ])
        return H264Remuxer
    }(BaseRemuxer))

    function appendByteArray(buffer1, buffer2) {
        const tmp = new Uint8Array((buffer1.byteLength | 0) + (buffer2.byteLength | 0))
        tmp.set(buffer1, 0)
        tmp.set(buffer2, buffer1.byteLength | 0)
        return tmp
    }

    function secToTime(sec) {
        let seconds = void 0;
            let hours = void 0;
            let minutes = void 0;
            let result = ''

        seconds = Math.floor(sec)
        hours = parseInt(seconds / 3600, 10) % 24
        minutes = parseInt(seconds / 60, 10) % 60
        seconds = seconds < 0 ? 0 : seconds % 60

        if (hours > 0) {
            result += `${hours < 10 ? `0${hours}` : hours}:`
        }
        result += `${minutes < 10 ? `0${minutes}` : minutes}:${seconds < 10 ? `0${seconds}` : seconds}`
        return result
    }

    const RemuxController = (function (_Event) {
        inherits(RemuxController, _Event)

        function RemuxController() {
            classCallCheck(this, RemuxController)

            const _this = possibleConstructorReturn(
                this,
                (RemuxController.__proto__ || Object.getPrototypeOf(RemuxController)).call(this, 'remuxer'),
            )

            _this.initialized = false
            _this.trackTypes = []
            _this.tracks = {}
            _this.mediaDuration = 1000000
            _this.iChannelId = 0
            _this.userData = {}
            return _this
        }

        createClass(RemuxController, [
            {
                key: 'addTrack',
                value: function addTrack(type) {
                    if (type === 'video' || type === 'both') {
                        this.tracks.video = new H264Remuxer()
                        this.trackTypes.push('video')
                    }
                    if (type === 'audio' || type === 'both') {
                        this.tracks.audio = new AACRemuxer()
                        this.trackTypes.push('audio')
                    }
                },
            },
            {
                key: 'postMP4Data',
                value: function postMP4Data(data) {
                    const msg = new Object()
                    msg.iChannelId = this.iChannelId
                    msg.userData = this.userData
                    msg.codec = data.codec
                    msg.data = data.payload
                    msg.strmType = data.type
                    postMessage(msg)
                },
            },
            {
                key: 'reset',
                value: function reset() {
                    this.tracks.video.resetTrack()
                    this.initialized = false
                },
            },
            {
                key: 'destroy',
                value: function destroy() {
                    this.tracks = {}
                    this.offAll()
                },
            },
            {
                key: 'flush',
                value: function flush(strmType) {
                    if (!this.initialized) {
                        if (this.isReady(strmType)) {
                            const track = this.tracks[strmType]
                            const code = `video/mp4; codecs="${track.mp4track.codec}"`
                            const data = {
                                type: strmType,
                                codec: code,
                                payload: MP4.initSegment(
                                    [track.mp4track],
                                    this.mediaDuration,
                                    track.mp4track.timescale,
                                ),
                            }
                            this.postMP4Data(data)
                            // console.log('Initial segment generated.');
                            this.initialized = true
                        }
                    } else {
                        const _track = this.tracks[strmType]
                        const pay = _track.getPayload()
                        if (pay && pay.byteLength) {
                            const moof = MP4.moof(_track.seq, _track.dts, _track.mp4track)
                            const mdat = MP4.mdat(pay)
                            const payload = appendByteArray(moof, mdat)
                            const _code = `video/mp4; codecs="${_track.mp4track.codec}"`
                            const _data = {
                                type: strmType,
                                codec: _code,
                                payload,
                                dts: _track.dts,
                            }
                            if ((_track.seq + 1) % 250 == 0) {
                                const duration = secToTime(_track.dts / 1000000)
                                // console.log("put segment video: "+track.seq+" dts: "+track.dts+" samples: "+track.mp4track.samples.length+" second: "+duration);
                            }

                            this.postMP4Data(_data)
                            _track.flush()
                        }
                    }
                },
            },
            {
                key: 'isReady',
                value: function isReady(strmType) {
                    if (!this.tracks[strmType].readyToDecode || !this.tracks[strmType].samples.length) return false
                    return true
                },
            },
            {
                key: 'remux',
                value: function remux(data, strmType) {
                    const samples = data[strmType]
                    this.iChannelId = data.iChannelId
                    this.userData = data.userData
                    if (samples.length > 0) {
                        this.tracks[strmType].remux(samples)
                    }
                    this.flush(strmType)
                },
            },
        ])
        return RemuxController
    }(Event))

    const JMuxmer = (function (_Event) {
        inherits(JMuxmer, _Event)

        function JMuxmer() {
            classCallCheck(this, JMuxmer)

            const _this = possibleConstructorReturn(
                this,
                (JMuxmer.__proto__ || Object.getPrototypeOf(JMuxmer)).call(this, 'jmuxer'),
            )

            _this.remuxController = new RemuxController()
            _this.remuxController.addTrack('both')
            return _this
        }

        createClass(JMuxmer, [
            {
                key: 'destroy',
                value: function destroy() {
                    if (this.remuxController) {
                        this.remuxController.destroy()
                        this.remuxController = null
                    }
                },
            },
            {
                key: 'feed',
                value: function feed(data) {
                    let frameStatus = false;
                        let type = '';
                        let nalus = void 0;
                        let aacFrames = void 0;
                        const chunks = {
                            video: [],
                            audio: [],
                            iChannelId: 0,
                            userData: {},
                        }

                    if (!data || !this.remuxController) return

                    chunks.iChannelId = data.iChannelId
                    chunks.userData = data.userData
                    this.frameDuration = data.time * 1000
                    if (this.frameDuration < 15) {
                        // console.log("frameDuration=" + this.frameDuration);
                        this.frameDuration += 10
                    }

                    if (data.video) {
                        type = 'video'
                        nalus = H264Parser.extractNALu(data.video)
                        if (nalus.length > 0) {
                            chunks.video = this.getVideoFrames(nalus)
                            frameStatus = true
                        }
                    } else if (data.audio) {
                        type = 'audio'
                        aacFrames = AACParser.extractAAC(data.audio)
                        if (aacFrames.length > 0) {
                            chunks.audio = this.getAudioFrames(aacFrames)
                            frameStatus = true
                        }
                    }
                    if (!frameStatus) {
                        console.error(
                            'Input object must have video and/or audio property. Make sure it is not empty and valid typed array',
                        )
                        return
                    }
                    this.remuxController.remux(chunks, type)
                },
            },
            {
                key: 'getVideoFrames',
                value: function getVideoFrames(nalus) {
                    let nalu = void 0;
                        let units = [];
                        const samples = [];
                        let naluObj = void 0;
                        let sampleDuration = void 0

                    let _iteratorNormalCompletion = true
                    let _didIteratorError = false
                    let _iteratorError

                    try {
                        for (
                            var _iterator = nalus[Symbol.iterator](), _step;
                            !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                            _iteratorNormalCompletion = true
                        ) {
                            nalu = _step.value

                            naluObj = new NALU(nalu)
                            units.push(naluObj)
                            if (naluObj.type() === NALU.IDR || naluObj.type() === NALU.NDR) {
                                samples.push({ units })
                                units = []
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true
                        _iteratorError = err
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return()
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError
                            }
                        }
                    }

                    sampleDuration = this.frameDuration

                    samples.map((sample) => {
                        sample.duration = sampleDuration
                    })

                    return samples
                },
            },
            {
                key: 'getAudioFrames',
                value: function getAudioFrames(aacFrames) {
                    const samples = [];
                        let units = void 0;
                        let sampleDuration = void 0

                    let _iteratorNormalCompletion2 = true
                    let _didIteratorError2 = false
                    let _iteratorError2

                    try {
                        for (
                            var _iterator2 = aacFrames[Symbol.iterator](), _step2;
                            !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
                            _iteratorNormalCompletion2 = true
                        ) {
                            units = _step2.value

                            samples.push({ units })
                        }
                    } catch (err) {
                        _didIteratorError2 = true
                        _iteratorError2 = err
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return()
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2
                            }
                        }
                    }

                    sampleDuration = this.frameDuration

                    samples.map((sample) => {
                        sample.duration = sampleDuration
                    })
                    return samples
                },
            },
        ])
        return JMuxmer
    }(Event))

    return JMuxmer
}))
